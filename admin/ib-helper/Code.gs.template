/**
 * IB Helper - Order Execution + User Authentication
 * Google Apps Script for Google Sheets
 *
 * @version 2.0.0
 * @author 100xFenok Claude
 * @decision DEC-153 (2026-02-03), DEC-154 (2026-02-03)
 *
 * HOW TO USE:
 * 1. Open your Google Sheet
 * 2. Extensions > Apps Script
 * 3. Paste this code
 * 4. Save (Ctrl+S)
 * 5. Deploy > New deployment > Web app
 *    - Execute as: Me
 *    - Who has access: Anyone
 * 6. Copy the Web App URL
 * 7. Run setupTrigger() once for daily auto-execution
 *
 * SHEET STRUCTURE REQUIRED:
 * - Sheet1 "Portfolio": Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ (A:L)
 * - Sheet2 "Prices": GOOGLEFINANCE Í∞ÄÍ≤© (ÏàòÎèô ÏÑ§Ï†ï)
 * - Sheet3 "Orders": Ï£ºÎ¨∏ ÌûàÏä§ÌÜ†Î¶¨ (A:M - auto-created)
 * - Sheet4 "Users": ÏÇ¨Ïö©Ïûê (A:D - auto-created)
 */

// =====================================================
// CONFIGURATION
// =====================================================

const CONFIG = {
  PORTFOLIO_SHEET: 'Portfolio',
  PRICES_SHEET: 'Prices',
  ORDERS_SHEET: 'Orders',
  USERS_SHEET: 'Users',      // ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù
  BALANCE_SHEET: 'Balance',  // Optional
  TIMEZONE: 'Asia/Seoul',
  TOKEN_EXPIRY_DAYS: 7       // ÏÑ∏ÏÖò ÌÜ†ÌÅ∞ ÎßåÎ£åÏùº
};

// =====================================================
// MAIN ENTRY POINTS
// =====================================================

/**
 * Process order executions
 * Main function - run daily at 09:00 KST (after US market close)
 */
function processOrderExecutions() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ordersSheet = ss.getSheetByName(CONFIG.ORDERS_SHEET);
  const pricesSheet = ss.getSheetByName(CONFIG.PRICES_SHEET);

  if (!ordersSheet) {
    Logger.log('Orders sheet not found');
    return;
  }

  if (!pricesSheet) {
    Logger.log('Prices sheet not found - please create it with GOOGLEFINANCE formulas');
    return;
  }

  // 1. Load yesterday's prices
  const prices = loadYesterdayPrices(pricesSheet);
  Logger.log('Loaded prices: ' + JSON.stringify(prices));

  // 2. Load pending orders (Ï≤¥Í≤∞ Ïª¨Îüº = ÎπàÍ∞í)
  const pendingOrders = loadPendingOrders(ordersSheet);
  Logger.log('Pending orders: ' + pendingOrders.length);

  // 3. Check executions
  const executedOrders = checkExecutions(pendingOrders, prices);
  Logger.log('Executed orders: ' + executedOrders.length);

  // 4. Update Orders sheet
  if (executedOrders.length > 0) {
    updateOrdersSheet(ordersSheet, executedOrders);

    // 5. Update Portfolio
    updatePortfolio(ss, executedOrders);
  }

  Logger.log('Process complete: ' + executedOrders.length + ' orders executed');
}

// =====================================================
// PRICE LOADING
// =====================================================

/**
 * Load yesterday's prices from Prices sheet
 * Expected structure:
 * | A: Ticker | B: Current | C: Close | D: High | E: Low |
 *
 * @param {Sheet} sheet - Prices sheet
 * @returns {Object} { TICKER: { close: number, high: number } }
 */
function loadYesterdayPrices(sheet) {
  const data = sheet.getDataRange().getValues();
  const prices = {};

  // Skip header row
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const ticker = String(row[0]).trim().toUpperCase();
    if (!ticker) continue;

    prices[ticker] = {
      close: parseFloat(row[2]) || 0,  // C: Close
      high: parseFloat(row[3]) || 0    // D: High
    };
  }

  return prices;
}

// =====================================================
// ORDER LOADING
// =====================================================

/**
 * Load pending orders from Orders sheet
 * Pending = Ï≤¥Í≤∞ Ïª¨Îüº (K) is empty
 *
 * @param {Sheet} sheet - Orders sheet
 * @returns {Array} Array of order objects
 */
function loadPendingOrders(sheet) {
  const data = sheet.getDataRange().getValues();
  const orders = [];

  // Skip header row
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const execution = String(row[10]).trim();  // K: Ï≤¥Í≤∞

    // Only pending orders
    if (execution !== '' && execution !== 'N') continue;

    orders.push({
      rowIndex: i + 1,  // 1-indexed for Sheet
      date: row[0],          // A: ÎÇ†Ïßú
      googleId: row[1],      // B: Íµ¨Í∏ÄID
      profileId: row[2],     // C: ÌîÑÎ°úÌïÑID
      ticker: String(row[3]).trim().toUpperCase(),  // D: Ï¢ÖÎ™©
      orderType: row[4],     // E: Ï£ºÎ¨∏ÌÉÄÏûÖ
      side: row[5],          // F: Îß§ÏàòÎß§ÎèÑ (BUY/SELL)
      price: parseFloat(row[6]) || 0,    // G: Í∞ÄÍ≤©
      quantity: parseInt(row[7]) || 0,   // H: ÏàòÎüâ
      total: parseFloat(row[8]) || 0,    // I: Ï¥ùÏï°
      executionBasis: row[9], // J: Ï≤¥Í≤∞Í∏∞Ï§Ä (CLOSE/HIGH)
      execution: row[10],    // K: Ï≤¥Í≤∞
      executionDate: row[11],// L: Ï≤¥Í≤∞Ïùº
      actualPrice: row[12]   // M: Ïã§Ï†úÍ∞ÄÍ≤©
    });
  }

  return orders;
}

// =====================================================
// EXECUTION CHECK
// =====================================================

/**
 * Check which orders were executed based on price
 *
 * Execution Rules:
 * - BUY + CLOSE: Ï¢ÖÍ∞Ä ‚â§ Ï£ºÎ¨∏Í∞Ä ‚Üí Ï≤¥Í≤∞
 * - SELL + CLOSE (LOC 25%): Ï¢ÖÍ∞Ä ‚â• Ï£ºÎ¨∏Í∞Ä ‚Üí Ï≤¥Í≤∞
 * - SELL + HIGH (ÏßÄÏ†ïÍ∞Ä 75%): Í≥†Í∞Ä ‚â• Ï£ºÎ¨∏Í∞Ä ‚Üí Ï≤¥Í≤∞
 *
 * @param {Array} orders - Pending orders
 * @param {Object} prices - Price data { TICKER: { close, high } }
 * @returns {Array} Orders that were executed
 */
function checkExecutions(orders, prices) {
  const today = Utilities.formatDate(new Date(), CONFIG.TIMEZONE, 'yyyy-MM-dd');
  const executedOrders = [];

  orders.forEach(order => {
    const priceData = prices[order.ticker];
    if (!priceData) {
      Logger.log('No price data for: ' + order.ticker);
      return;
    }

    let executed = false;
    let actualPrice = 0;

    if (order.side === 'BUY') {
      // Îß§Ïàò: Ï¢ÖÍ∞Ä ‚â§ Ï£ºÎ¨∏Í∞Ä
      if (order.executionBasis === 'CLOSE' && priceData.close <= order.price) {
        executed = true;
        actualPrice = priceData.close;
      }
    } else if (order.side === 'SELL') {
      if (order.executionBasis === 'CLOSE') {
        // LOC Îß§ÎèÑ: Ï¢ÖÍ∞Ä ‚â• Ï£ºÎ¨∏Í∞Ä
        if (priceData.close >= order.price) {
          executed = true;
          actualPrice = priceData.close;
        }
      } else if (order.executionBasis === 'HIGH') {
        // ÏßÄÏ†ïÍ∞Ä Îß§ÎèÑ: Í≥†Í∞Ä ‚â• Ï£ºÎ¨∏Í∞Ä
        if (priceData.high >= order.price) {
          executed = true;
          actualPrice = order.price;  // ÏßÄÏ†ïÍ∞Ä Ï≤¥Í≤∞
        }
      }
    }

    if (executed) {
      order.execution = 'Y';
      order.executionDate = today;
      order.actualPrice = actualPrice;
      executedOrders.push(order);
    }
  });

  return executedOrders;
}

// =====================================================
// SHEET UPDATES
// =====================================================

/**
 * Update Orders sheet with execution results
 *
 * @param {Sheet} sheet - Orders sheet
 * @param {Array} executedOrders - Orders that were executed
 */
function updateOrdersSheet(sheet, executedOrders) {
  executedOrders.forEach(order => {
    const row = order.rowIndex;

    // K: Ï≤¥Í≤∞ = 'Y'
    sheet.getRange(row, 11).setValue('Y');

    // L: Ï≤¥Í≤∞Ïùº
    sheet.getRange(row, 12).setValue(order.executionDate);

    // M: Ïã§Ï†úÍ∞ÄÍ≤©
    sheet.getRange(row, 13).setValue(order.actualPrice);
  });
}

/**
 * Update Portfolio sheet based on executed orders
 *
 * Portfolio columns:
 * | A: Íµ¨Í∏ÄID | B: ÌîÑÎ°úÌïÑID | C: Ï¢ÖÎ™© | D: ÌèâÎã®Í∞Ä | E: ÏàòÎüâ | F: Ï¥ùÎß§ÏûÖÍ∏à | G: ÏÑ∏ÌåÖÏõêÍ∏à | H: ÎÇ†Ïßú |
 *
 * @param {Spreadsheet} ss - Spreadsheet
 * @param {Array} executedOrders - Orders that were executed
 */
function updatePortfolio(ss, executedOrders) {
  const portfolioSheet = ss.getSheetByName(CONFIG.PORTFOLIO_SHEET);
  if (!portfolioSheet) {
    Logger.log('Portfolio sheet not found');
    return;
  }

  const data = portfolioSheet.getDataRange().getValues();
  const today = Utilities.formatDate(new Date(), CONFIG.TIMEZONE, 'yyyy-MM-dd');

  // Group executed orders by googleId + profileId + ticker
  const ordersByKey = {};
  executedOrders.forEach(order => {
    const key = `${order.googleId}|${order.profileId}|${order.ticker}`;
    if (!ordersByKey[key]) {
      ordersByKey[key] = { buys: [], sells: [] };
    }
    if (order.side === 'BUY') {
      ordersByKey[key].buys.push(order);
    } else {
      ordersByKey[key].sells.push(order);
    }
  });

  // Update each portfolio row
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const key = `${row[0]}|${row[1]}|${row[2]}`;  // A|B|C
    const orders = ordersByKey[key];

    if (!orders) continue;

    let avgPrice = parseFloat(row[3]) || 0;
    let holdings = parseInt(row[4]) || 0;
    let totalInvested = parseFloat(row[5]) || 0;

    // Process buys: increase holdings, recalculate avgPrice
    orders.buys.forEach(order => {
      const newCost = order.actualPrice * order.quantity;
      totalInvested += newCost;
      holdings += order.quantity;
    });

    // Process sells: decrease holdings, reduce totalInvested
    orders.sells.forEach(order => {
      // Reduce holdings
      holdings -= order.quantity;
      // Reduce totalInvested proportionally
      if (holdings > 0 && avgPrice > 0) {
        totalInvested = avgPrice * holdings;
      } else if (holdings <= 0) {
        totalInvested = 0;
        holdings = 0;
      }
    });

    // Recalculate avgPrice
    if (holdings > 0 && totalInvested > 0) {
      avgPrice = totalInvested / holdings;
    } else {
      avgPrice = 0;
    }

    // Update row (1-indexed, add 1 for header)
    const rowNum = i + 1;
    portfolioSheet.getRange(rowNum, 4).setValue(avgPrice);      // D: ÌèâÎã®Í∞Ä
    portfolioSheet.getRange(rowNum, 5).setValue(holdings);      // E: ÏàòÎüâ
    portfolioSheet.getRange(rowNum, 6).setValue(totalInvested); // F: Ï¥ùÎß§ÏûÖÍ∏à
    portfolioSheet.getRange(rowNum, 8).setValue(today);         // H: ÎÇ†Ïßú

    Logger.log('Updated portfolio: ' + key + ' ‚Üí holdings=' + holdings + ', avgPrice=' + avgPrice);
  }
}

// =====================================================
// TRIGGER SETUP
// =====================================================

/**
 * Setup daily trigger - run once to enable auto-execution
 * Runs at 09:00 KST (after US market close)
 */
function setupTrigger() {
  // Remove existing triggers
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'processOrderExecutions') {
      ScriptApp.deleteTrigger(trigger);
    }
  });

  // Create new daily trigger
  ScriptApp.newTrigger('processOrderExecutions')
    .timeBased()
    .atHour(9)
    .everyDays(1)
    .inTimezone(CONFIG.TIMEZONE)
    .create();

  Logger.log('Daily trigger set for 09:00 KST');
}

/**
 * Remove daily trigger
 */
function removeTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'processOrderExecutions') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  Logger.log('Trigger removed');
}

// =====================================================
// MENU (for manual execution)
// =====================================================

/**
 * Add custom menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üìä IB Helper')
    .addItem('Ï≤¥Í≤∞ ÌôïÏù∏ Ïã§Ìñâ', 'processOrderExecutions')
    .addSeparator()
    .addItem('Îß§Ïùº ÏûêÎèô Ïã§Ìñâ ÏÑ§Ï†ï', 'setupTrigger')
    .addItem('ÏûêÎèô Ïã§Ìñâ Ìï¥Ï†ú', 'removeTrigger')
    .addToUi();
}

// =====================================================
// UTILITIES
// =====================================================

/**
 * Manual test function
 */
function testPriceLoading() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const pricesSheet = ss.getSheetByName(CONFIG.PRICES_SHEET);

  if (!pricesSheet) {
    Logger.log('Prices sheet not found');
    return;
  }

  const prices = loadYesterdayPrices(pricesSheet);
  Logger.log('Prices: ' + JSON.stringify(prices, null, 2));
}

/**
 * Create Prices sheet template
 * Run this once to set up the Prices sheet structure
 */
function createPricesSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.PRICES_SHEET);

  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.PRICES_SHEET);
  }

  // Headers
  sheet.getRange('A1:E1').setValues([['Ticker', 'Current', 'Close', 'High', 'Low']]);

  // Example formulas for common tickers
  const tickers = ['TQQQ', 'SOXL'];
  tickers.forEach((ticker, i) => {
    const row = i + 2;
    sheet.getRange(row, 1).setValue(ticker);
    sheet.getRange(row, 2).setFormula(`=GOOGLEFINANCE("${ticker}", "price")`);
    sheet.getRange(row, 3).setFormula(`=GOOGLEFINANCE("${ticker}", "closeyest")`);
    sheet.getRange(row, 4).setFormula(`=GOOGLEFINANCE("${ticker}", "high")`);
    sheet.getRange(row, 5).setFormula(`=GOOGLEFINANCE("${ticker}", "low")`);
  });

  // Formatting
  sheet.getRange('A1:E1').setFontWeight('bold').setBackground('#f3f4f6');
  sheet.setFrozenRows(1);

  Logger.log('Prices sheet created with GOOGLEFINANCE formulas');
}

// =====================================================
// WEB APP ENTRY POINTS (doPost / doGet)
// =====================================================

/**
 * Handle POST requests (main API endpoint)
 * @param {Object} e - Event object
 * @returns {TextOutput} JSON response
 */
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;

    let result;

    switch (action) {
      case 'register':
        result = registerUser(data.email, data.password);
        break;
      case 'login':
        result = loginUser(data.email, data.password);
        break;
      case 'verify':
        result = verifyToken(data.token);
        break;
      case 'getData':
        result = getUserData(data.token, data.profileId);
        break;
      case 'saveData':
        result = saveUserData(data.token, data.profileId, data.stocks, data.balance);
        break;
      default:
        result = { success: false, error: 'Unknown action: ' + action };
    }

    return ContentService
      .createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    return ContentService
      .createTextOutput(JSON.stringify({ success: false, error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Handle GET requests (for CORS preflight and health check)
 * @param {Object} e - Event object
 * @returns {TextOutput} JSON response
 */
function doGet(e) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'ok', version: '2.0.0' }))
    .setMimeType(ContentService.MimeType.JSON);
}

// =====================================================
// USER AUTHENTICATION
// =====================================================

/**
 * Register new user
 * @param {string} email - User email
 * @param {string} password - User password
 * @returns {Object} { success, token?, error? }
 */
function registerUser(email, password) {
  if (!email || !password) {
    return { success: false, error: 'Ïù¥Î©îÏùºÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî' };
  }

  // Validate email format
  if (!isValidEmail(email)) {
    return { success: false, error: 'Ïò¨Î∞îÎ•∏ Ïù¥Î©îÏùº ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§' };
  }

  // Password minimum length
  if (password.length < 4) {
    return { success: false, error: 'ÎπÑÎ∞ÄÎ≤àÌò∏Îäî 4Ïûê Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§' };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let usersSheet = ss.getSheetByName(CONFIG.USERS_SHEET);

  // Create Users sheet if not exists
  if (!usersSheet) {
    usersSheet = createUsersSheet(ss);
  }

  // Check if email already exists (Ï§ëÎ≥µ Ï≤¥ÌÅ¨!)
  const existingUser = findUserByEmail(usersSheet, email);
  if (existingUser) {
    return { success: false, error: 'Ïù¥ÎØ∏ Í∞ÄÏûÖÎêú Ïù¥Î©îÏùºÏûÖÎãàÎã§' };
  }

  // Hash password
  const passwordHash = hashPassword(password);

  // Generate token
  const token = generateToken(email);
  const tokenExpiry = new Date();
  tokenExpiry.setDate(tokenExpiry.getDate() + CONFIG.TOKEN_EXPIRY_DAYS);

  // Add user to sheet
  // Columns: A: email | B: passwordHash | C: token | D: tokenExpiry | E: createdAt
  const now = new Date();
  usersSheet.appendRow([
    email,
    passwordHash,
    token,
    tokenExpiry.toISOString(),
    now.toISOString()
  ]);

  Logger.log('User registered: ' + email);

  return {
    success: true,
    token: token,
    email: email,
    expiresAt: tokenExpiry.toISOString()
  };
}

/**
 * Login user
 * @param {string} email - User email
 * @param {string} password - User password
 * @returns {Object} { success, token?, error? }
 */
function loginUser(email, password) {
  if (!email || !password) {
    return { success: false, error: 'Ïù¥Î©îÏùºÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî' };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const usersSheet = ss.getSheetByName(CONFIG.USERS_SHEET);

  if (!usersSheet) {
    return { success: false, error: 'Í∞ÄÏûÖÎêú ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§' };
  }

  // Find user
  const user = findUserByEmail(usersSheet, email);
  if (!user) {
    return { success: false, error: 'Îì±Î°ùÎêòÏßÄ ÏïäÏùÄ Ïù¥Î©îÏùºÏûÖÎãàÎã§' };
  }

  // Verify password
  const passwordHash = hashPassword(password);
  if (user.passwordHash !== passwordHash) {
    return { success: false, error: 'ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§' };
  }

  // Generate new token
  const token = generateToken(email);
  const tokenExpiry = new Date();
  tokenExpiry.setDate(tokenExpiry.getDate() + CONFIG.TOKEN_EXPIRY_DAYS);

  // Update token in sheet
  usersSheet.getRange(user.rowIndex, 3).setValue(token);
  usersSheet.getRange(user.rowIndex, 4).setValue(tokenExpiry.toISOString());

  Logger.log('User logged in: ' + email);

  return {
    success: true,
    token: token,
    email: email,
    expiresAt: tokenExpiry.toISOString()
  };
}

/**
 * Verify token
 * @param {string} token - Session token
 * @returns {Object} { success, email?, error? }
 */
function verifyToken(token) {
  if (!token) {
    return { success: false, error: 'ÌÜ†ÌÅ∞Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§' };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const usersSheet = ss.getSheetByName(CONFIG.USERS_SHEET);

  if (!usersSheet) {
    return { success: false, error: 'Ïù∏Ï¶ù Ïã§Ìå®' };
  }

  const user = findUserByToken(usersSheet, token);
  if (!user) {
    return { success: false, error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§' };
  }

  // Check expiry
  const expiry = new Date(user.tokenExpiry);
  if (new Date() > expiry) {
    return { success: false, error: 'ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏ÌïòÏÑ∏Ïöî' };
  }

  return {
    success: true,
    email: user.email
  };
}

// =====================================================
// USER DATA (Portfolio CRUD)
// =====================================================

/**
 * Get user's portfolio data
 * @param {string} token - Session token
 * @param {string} profileId - Profile ID (optional)
 * @returns {Object} { success, data?, error? }
 */
function getUserData(token, profileId) {
  // Verify token first
  const auth = verifyToken(token);
  if (!auth.success) {
    return auth;
  }

  const email = auth.email;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const portfolioSheet = ss.getSheetByName(CONFIG.PORTFOLIO_SHEET);

  if (!portfolioSheet) {
    return { success: true, data: [] };
  }

  const data = portfolioSheet.getDataRange().getValues();
  const userRows = [];

  // Filter by email (and optionally profileId)
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (row[0] === email) {
      if (!profileId || row[1] === profileId) {
        userRows.push({
          profileId: row[1],
          profileName: row[2],
          ticker: row[3],
          avgPrice: row[4],
          holdings: row[5],
          totalInvested: row[6],
          principal: row[7],
          sellPercent: row[8],
          locSellPercent: row[9],
          date: row[10],
          balance: row[11]
        });
      }
    }
  }

  return { success: true, data: userRows };
}

/**
 * Save user's portfolio data
 * @param {string} token - Session token
 * @param {string} profileId - Profile ID
 * @param {Array} stocks - Stocks array
 * @param {number} balance - Balance
 * @returns {Object} { success, error? }
 */
function saveUserData(token, profileId, stocks, balance) {
  // Verify token first
  const auth = verifyToken(token);
  if (!auth.success) {
    return auth;
  }

  const email = auth.email;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let portfolioSheet = ss.getSheetByName(CONFIG.PORTFOLIO_SHEET);

  // Create sheet if not exists
  if (!portfolioSheet) {
    portfolioSheet = ss.insertSheet(CONFIG.PORTFOLIO_SHEET);
    portfolioSheet.appendRow([
      'Íµ¨Í∏ÄID', 'ÌîÑÎ°úÌïÑID', 'ÌîÑÎ°úÌïÑÏù¥Î¶Ñ', 'Ï¢ÖÎ™©', 'ÌèâÎã®Í∞Ä', 'ÏàòÎüâ',
      'Ï¥ùÎß§ÏûÖÍ∏à', 'ÏÑ∏ÌåÖÏõêÍ∏à', 'AFTER%', 'LOC%', 'ÎÇ†Ïßú', 'ÏòàÏàòÍ∏à'
    ]);
  }

  const data = portfolioSheet.getDataRange().getValues();
  const today = Utilities.formatDate(new Date(), CONFIG.TIMEZONE, 'yyyy-MM-dd');

  // Delete existing rows for this user+profile
  const rowsToDelete = [];
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][0] === email && data[i][1] === profileId) {
      rowsToDelete.push(i + 1);
    }
  }
  rowsToDelete.forEach(row => portfolioSheet.deleteRow(row));

  // Add new rows
  stocks.forEach((stock, index) => {
    portfolioSheet.appendRow([
      email,
      profileId,
      stock.profileName || '',
      stock.ticker,
      stock.avgPrice || 0,
      stock.holdings || 0,
      stock.totalInvested || 0,
      stock.principal || 0,
      stock.sellPercent || 10,
      stock.locSellPercent || 5,
      today,
      index === 0 ? (balance || 0) : 0
    ]);
  });

  Logger.log('Data saved for: ' + email + '/' + profileId);

  return { success: true };
}

// =====================================================
// HELPER FUNCTIONS
// =====================================================

/**
 * Find user by email
 * @param {Sheet} sheet - Users sheet
 * @param {string} email - Email to find
 * @returns {Object|null} User object or null
 */
function findUserByEmail(sheet, email) {
  const data = sheet.getDataRange().getValues();

  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === email) {
      return {
        rowIndex: i + 1,
        email: data[i][0],
        passwordHash: data[i][1],
        token: data[i][2],
        tokenExpiry: data[i][3],
        createdAt: data[i][4]
      };
    }
  }

  return null;
}

/**
 * Find user by token
 * @param {Sheet} sheet - Users sheet
 * @param {string} token - Token to find
 * @returns {Object|null} User object or null
 */
function findUserByToken(sheet, token) {
  const data = sheet.getDataRange().getValues();

  for (let i = 1; i < data.length; i++) {
    if (data[i][2] === token) {
      return {
        rowIndex: i + 1,
        email: data[i][0],
        passwordHash: data[i][1],
        token: data[i][2],
        tokenExpiry: data[i][3],
        createdAt: data[i][4]
      };
    }
  }

  return null;
}

/**
 * Hash password (simple SHA-256)
 * @param {string} password - Plain password
 * @returns {string} Hashed password
 */
function hashPassword(password) {
  const hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);
  return hash.map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join('');
}

/**
 * Generate random token
 * @param {string} email - User email
 * @returns {string} Random token
 */
function generateToken(email) {
  const timestamp = new Date().getTime();
  const random = Math.random().toString(36).substring(2);
  const data = email + timestamp + random;
  const hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, data);
  return hash.map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join('');
}

/**
 * Validate email format
 * @param {string} email - Email to validate
 * @returns {boolean} Is valid
 */
function isValidEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

/**
 * Create Users sheet with headers
 * @param {Spreadsheet} ss - Spreadsheet
 * @returns {Sheet} Created sheet
 */
function createUsersSheet(ss) {
  const sheet = ss.insertSheet(CONFIG.USERS_SHEET);
  sheet.appendRow(['Ïù¥Î©îÏùº', 'ÎπÑÎ∞ÄÎ≤àÌò∏Ìï¥Ïãú', 'ÌÜ†ÌÅ∞', 'ÌÜ†ÌÅ∞ÎßåÎ£å', 'Í∞ÄÏûÖÏùº']);
  sheet.getRange('A1:E1').setFontWeight('bold').setBackground('#f3f4f6');
  sheet.setFrozenRows(1);
  Logger.log('Users sheet created');
  return sheet;
}
